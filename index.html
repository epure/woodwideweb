<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Wood Wide Web AR</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Scripts chargÃ©s directement -->
    <script src="https://cdn.jsdelivr.net/npm/aframe@1.4.2/dist/aframe-master.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image.prod.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
    
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'IBM Plex Mono', monospace;
        }
        
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10000;
        }
        
        #loading.hide {
            display: none;
        }
        
        #loading h2 {
            font-family: 'IBM Plex Mono', monospace;
            font-weight: 500;
            letter-spacing: 0.05em;
        }
        
        #loading p {
            font-family: 'IBM Plex Mono', monospace;
            font-weight: 400;
        }
        
        #progress-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 10px;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        }
        
        #progress-bar {
            height: 100%;
            width: 0%;
            background: white;
            transition: width 0.1s linear;
        }
        
        #debug {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 9px;
            background: rgba(0,0,0,0.8);
            padding: 8px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 999;
            max-width: 300px;
            max-height: 300px;
            overflow-y: auto;
            line-height: 1.3;
        }
        
        #video-canvas {
            display: none;
        }
    </style>
</head>
<body>
    <div id="loading">
        <h2>Wood Wide Web</h2>
        <p style="margin-top: 10px; font-size: 14px; opacity: 0.9;">Chargement...</p>
        <p id="loading-status" style="margin-top: 5px; font-size: 12px; opacity: 0.7;">Initialisation</p>
    </div>
    
    <div id="progress-container">
        <div id="progress-bar"></div>
    </div>
    
    <div id="debug"></div>
    
    <!-- Canvas pour gÃ©nÃ©rer la vidÃ©o -->
    <canvas id="video-canvas" width="640" height="640"></canvas>
    
    <a-scene 
        mindar-image="imageTargetSrc: ./targets.mind; uiScanning: no; filterMinCF: 0.001; filterBeta: 50; warmupTolerance: 5; missTolerance: 5"
        color-space="sRGB"
        renderer="colorManagement: true; antialias: true"
        vr-mode-ui="enabled: false"
        device-orientation-permission-ui="enabled: false">
        
        <a-assets>
            <!-- Canvas comme source vidÃ©o -->
            <canvas 
                id="vid"
                width="640" 
                height="640">
            </canvas>
        </a-assets>
        
        <a-camera 
            position="0 0 0" 
            look-controls="enabled: false"
            wasd-controls="enabled: false">
        </a-camera>
        
        <a-entity mindar-image-target="targetIndex: 0">
            <a-plane
                id="video-plane"
                material="src: #vid; shader: flat; side: double; transparent: false; opacity: 1"
                position="0 0 0"
                rotation="0 0 0"
                width="1.01"
                height="1.01"
                visible="true"
                geometry="primitive: plane"
                corner-anchor>
            </a-plane>
        </a-entity>
    </a-scene>
    
    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // VIDÃ‰O PROCÃ‰DURALE (CANVAS)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        const debugDiv = document.getElementById('debug');
        const loadingStatus = document.getElementById('loading-status');
        
        function updateDebug(msg) {
            console.log(msg);
            const timestamp = new Date().toLocaleTimeString().split(':').slice(1).join(':');
            debugDiv.innerHTML += `[${timestamp}] ${msg}<br>`;
            const lines = debugDiv.innerHTML.split('<br>');
            if (lines.length > 25) {
                debugDiv.innerHTML = lines.slice(-25).join('<br>');
            }
            debugDiv.scrollTop = debugDiv.scrollHeight;
        }
        
        updateDebug('ğŸš€ DÃ©marrage');
        
        // GÃ©nÃ©rateur de vidÃ©o procÃ©durale
        class ProceduralVideo {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.width = canvas.width;
                this.height = canvas.height;
                this.frame = 0;
                this.isPlaying = false;
                this.animationId = null;
                
                updateDebug('ğŸ¨ Canvas vidÃ©o crÃ©Ã©: ' + this.width + 'x' + this.height);
            }
            
            render() {
                const ctx = this.ctx;
                const w = this.width;
                const h = this.height;
                const t = this.frame / 60; // Temps en secondes
                
                // Fond gradient animÃ©
                const gradient = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, w/2);
                const hue1 = (t * 20) % 360;
                const hue2 = (t * 20 + 120) % 360;
                gradient.addColorStop(0, `hsl(${hue1}, 70%, 50%)`);
                gradient.addColorStop(1, `hsl(${hue2}, 70%, 30%)`);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, w, h);
                
                // Cercles animÃ©s (mycelium)
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                
                for (let i = 0; i < 8; i++) {
                    const angle = (t + i * 0.5) * Math.PI * 2 / 8;
                    const radius = 100 + Math.sin(t * 2 + i) * 50;
                    const x = w/2 + Math.cos(angle) * radius;
                    const y = h/2 + Math.sin(angle) * radius;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 30 + Math.sin(t * 3 + i) * 10, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Lignes connectÃ©es (rÃ©seau)
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 8; i++) {
                    const angle1 = (t + i * 0.5) * Math.PI * 2 / 8;
                    const angle2 = (t + (i + 1) * 0.5) * Math.PI * 2 / 8;
                    const radius = 100 + Math.sin(t * 2 + i) * 50;
                    
                    const x1 = w/2 + Math.cos(angle1) * radius;
                    const y1 = h/2 + Math.sin(angle1) * radius;
                    const x2 = w/2 + Math.cos(angle2) * radius;
                    const y2 = h/2 + Math.sin(angle2) * radius;
                    
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
                
                // Texte central
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = 'bold 48px "IBM Plex Mono", monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('WOOD', w/2, h/2 - 30);
                ctx.fillText('WIDE', w/2, h/2 + 10);
                ctx.fillText('WEB', w/2, h/2 + 50);
                
                // Compteur de frames
                ctx.font = '12px "IBM Plex Mono", monospace';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.fillText('Frame: ' + this.frame, w - 60, 20);
                
                this.frame++;
            }
            
            play() {
                if (this.isPlaying) return;
                this.isPlaying = true;
                updateDebug('â–¶ï¸ Canvas play');
                this.animate();
            }
            
            pause() {
                this.isPlaying = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
                updateDebug('â¸ï¸ Canvas pause');
            }
            
            animate() {
                if (!this.isPlaying) return;
                
                this.render();
                this.animationId = requestAnimationFrame(() => this.animate());
            }
        }
        
        let proceduralVideo = null;
        
        // Attendre que tout soit chargÃ©
        window.addEventListener('load', function() {
            updateDebug('âœ… Window load');
            
            // VÃ©rifier les dÃ©pendances
            let checkCount = 0;
            const maxChecks = 50;
            
            function checkDependencies() {
                checkCount++;
                
                if (typeof AFRAME === 'undefined' || 
                    typeof THREE === 'undefined' || 
                    typeof window.MINDAR === 'undefined') {
                    
                    if (checkCount < maxChecks) {
                        updateDebug('â³ Attente libs... (' + checkCount + ')');
                        setTimeout(checkDependencies, 200);
                    } else {
                        updateDebug('âŒ Timeout libs');
                        loadingStatus.textContent = 'Erreur chargement';
                    }
                    return;
                }
                
                updateDebug('âœ… AFRAME v' + AFRAME.version);
                updateDebug('âœ… THREE r' + THREE.REVISION);
                updateDebug('âœ… MINDAR OK');
                
                initApp();
            }
            
            checkDependencies();
        });
        
        function initApp() {
            updateDebug('ğŸ¬ Init app');
            loadingStatus.textContent = 'Initialisation AR...';
            
            // CrÃ©er la vidÃ©o procÃ©durale
            const canvas = document.getElementById('vid');
            proceduralVideo = new ProceduralVideo(canvas);
            
            // Rendre la premiÃ¨re frame
            proceduralVideo.render();
            
            updateDebug('âœ… VidÃ©o procÃ©durale prÃªte');
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // CORNER-ANCHOR : Ancrage par les 4 coins
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            AFRAME.registerComponent('corner-anchor', {
                init: function() {
                    this.corners = [
                        new THREE.Vector3(-0.5, 0.5, 0),
                        new THREE.Vector3(0.5, 0.5, 0),
                        new THREE.Vector3(0.5, -0.5, 0),
                        new THREE.Vector3(-0.5, -0.5, 0)
                    ];
                    
                    this.worldCorners = [
                        new THREE.Vector3(),
                        new THREE.Vector3(),
                        new THREE.Vector3(),
                        new THREE.Vector3()
                    ];
                    
                    this.frozenCorners = null;
                    this.stableFrames = 0;
                    this.isFrozen = false;
                    
                    updateDebug('ğŸ“ Corner-anchor OK');
                },
                
                tick: function() {
                    const plane = this.el;
                    const target = this.el.parentEl;
                    
                    if (!target) return;
                    
                    if (this.isFrozen && this.frozenCorners) {
                        this.applyCorners(this.frozenCorners);
                        return;
                    }
                    
                    target.object3D.updateMatrixWorld(true);
                    const worldMatrix = target.object3D.matrixWorld;
                    
                    for (let i = 0; i < 4; i++) {
                        this.worldCorners[i].copy(this.corners[i]);
                        this.worldCorners[i].applyMatrix4(worldMatrix);
                    }
                    
                    if (this.lastWorldCorners) {
                        let maxMovement = 0;
                        for (let i = 0; i < 4; i++) {
                            const dist = this.worldCorners[i].distanceTo(this.lastWorldCorners[i]);
                            maxMovement = Math.max(maxMovement, dist);
                        }
                        
                        if (maxMovement < 0.002) {
                            this.stableFrames++;
                            
                            if (this.stableFrames > 15) {
                                this.isFrozen = true;
                                this.frozenCorners = this.worldCorners.map(c => c.clone());
                                updateDebug('ğŸ”’ FigÃ©');
                            }
                        } else {
                            this.stableFrames = 0;
                        }
                    }
                    
                    this.lastWorldCorners = this.worldCorners.map(c => c.clone());
                    this.applyCorners(this.worldCorners);
                },
                
                applyCorners: function(corners) {
                    const plane = this.el;
                    
                    const center = new THREE.Vector3();
                    corners.forEach(c => center.add(c));
                    center.divideScalar(4);
                    
                    plane.object3D.position.copy(center);
                    
                    const right = new THREE.Vector3().subVectors(corners[1], corners[0]).normalize();
                    const down = new THREE.Vector3().subVectors(corners[3], corners[0]).normalize();
                    const normal = new THREE.Vector3().crossVectors(right, down).normalize();
                    const up = down.clone().negate();
                    
                    const rotMatrix = new THREE.Matrix4();
                    rotMatrix.makeBasis(right, up, normal);
                    
                    const rotation = new THREE.Quaternion().setFromRotationMatrix(rotMatrix);
                    plane.object3D.quaternion.copy(rotation);
                    
                    const width = corners[0].distanceTo(corners[1]);
                    const height = corners[0].distanceTo(corners[3]);
                    
                    const scaleX = Math.max(width, 0.01);
                    const scaleY = Math.max(height, 0.01);
                    
                    plane.object3D.scale.set(scaleX, scaleY, 1);
                }
            });
            
            updateDebug('âœ… Composant OK');
            
            setupEvents();
        }
        
        function setupEvents() {
            const loading = document.getElementById('loading');
            const progressBar = document.getElementById('progress-bar');
            const scene = document.querySelector('a-scene');
            const target = document.querySelector('[mindar-image-target]');
            
            if (!scene) {
                updateDebug('âŒ ScÃ¨ne non trouvÃ©e');
                return;
            }
            
            updateDebug('âœ… Ã‰lÃ©ments trouvÃ©s');
            
            let hasPlayedSound = false;
            
            // Ã‰vÃ©nements target
            if (target) {
                updateDebug('âœ… Target OK');
                
                target.addEventListener('targetFound', () => {
                    updateDebug('ğŸ¯ DÃ©tectÃ©e!');
                    
                    if (!hasPlayedSound) {
                        playHapticSound();
                        hasPlayedSound = true;
                    }
                    
                    const plane = document.querySelector('#video-plane');
                    if (plane && plane.components['corner-anchor']) {
                        plane.components['corner-anchor'].isFrozen = false;
                        plane.components['corner-anchor'].stableFrames = 0;
                    }
                    
                    // DÃ©marrer l'animation canvas
                    if (proceduralVideo) {
                        proceduralVideo.play();
                    }
                });
                
                target.addEventListener('targetLost', () => {
                    updateDebug('âŒ Perdue');
                    
                    // Pause l'animation canvas
                    if (proceduralVideo) {
                        proceduralVideo.pause();
                    }
                    
                    hasPlayedSound = false;
                });
            }
            
            // Ã‰vÃ©nement scÃ¨ne chargÃ©e
            scene.addEventListener('loaded', () => {
                updateDebug('âœ… ScÃ¨ne chargÃ©e');
                setTimeout(() => {
                    loading.classList.add('hide');
                }, 1500);
            });
        }
        
        function playHapticSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.type = 'sine';
                oscillator.frequency.value = 800;
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.1);
                
                return true;
            } catch (e) {
                return false;
            }
        }
    </script>
</body>
</html>
